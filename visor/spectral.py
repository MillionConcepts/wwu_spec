# utilities for interpreting and manipulating filter data

import json

import numpy as np
import pandas as pd
from scipy import integrate, interpolate

import visor.models


def interpolate_spectrum(
    ref_wavelengths: np.ndarray,
    input_wavelengths: np.ndarray,
    input_spectrum: np.ndarray,
) -> np.ndarray:
    interpolator = interpolate.interp1d(
        input_wavelengths,
        input_spectrum,
        kind="linear",
        bounds_error=False,
        fill_value=0,
    )
    output_spectrum = interpolator(ref_wavelengths)
    return output_spectrum


# noinspection PyTypeChecker
def normalize_power(spectrum: pd.Series, bins: np.ndarray) -> pd.Series:
    return spectrum / integrate.trapz(spectrum.values, bins)


def convolve(
    radiance: np.ndarray,
    responsivity: np.ndarray,
    bins: np.ndarray,
    irradiance: bool = None,
) -> float:
    output = integrate.trapz(radiance * responsivity, bins)
    if irradiance is None:
        scale = 1
    else:
        scale = integrate.trapz(responsivity * irradiance, bins)
    return output / scale


def simulate_spectrum(
    sample: "visor.models.Sample", filterset: "visor.models.FilterSet",
) -> pd.DataFrame:
    # turn sample values into nice arrays
    sample_data = sample.data_array
    sample_wavelengths = sample_data[:, 0]
    reflectance = sample_data[:, 1]

    # trim and interpolate these values to the bins of the filterset; treat
    # this as target radiance
    radiance = interpolate_spectrum(
        filterset.wave_array, sample_wavelengths, reflectance
    )

    # if we hadn't already power-normalized the filters, we would normalize
    # them here, but our filtersets should all be power-normalized at upload.

    # create blank spectral response dataframe
    simulated_spectrum = pd.DataFrame(
        filterset.filter_centers, columns=["filter", "wavelength"],
    ).sort_values(["wavelength"])

    # is this filterset assumed to have flat response across spectral bins
    # (like many high-resolution spectrometers)?
    if filterset.resample_only is True:
        simulated_spectrum["response"] = radiance
    else:
        # otherwise, convolve reflectance with each of the filters and stick it
        # in the spectral response dataframe.
        simulated_spectrum["response"] = [
            convolve(
                radiance, filterset.filterbank[filt], filterset.wave_array
            )
            for filt in simulated_spectrum["filter"]
        ]
    return simulated_spectrum


# noinspection PyUnresolvedReferences
def make_filterset(
    name: str,
    filters: dict,
    bins: np.ndarray,
    waves: dict[str, float],
):
    """
    make_filterset below is a convenience function for generating filtersets.
    'filters' is a dict formatted like: {'filter_name':pandas dataframe of
    wavelength&response, 'filter_name_2'...} this might be generated by,
    for instance, using pd.read_csv on a directory of csv files,
    or by generating curves from a list of mathematical specifications,
    like: (for a dict DIST of {name:distribution} with distributions given as
    band center / FWHM)

    from scipy.stats import norm
    filters = {
        filt:pd.DataFrame(
               ([n,norm(DISTS[filt][0], DISTS[filt][1]/2.355).pdf(n)]
            for n in bins),
            columns=['wavelength','responsivity']
        )
        for filt in DISTS
    }

    'bins' is a reference array of wavelength bins; should span range of all
    filters in set. 'waves' gives the nominal center wavelength of each filter (
    used only for graphing convolved spectra); this is a dict formatted like
    {'filter_name':center_wavelength,'filter_name_2'...}
    """
    # 'filter' is a python builtin so not a good variable name
    for filt in filters:
        filters[filt] = pd.DataFrame(
            {
                "wavelength": bins,
                "responsivity": interpolate_spectrum(
                    bins,
                    filters[filt]["wavelength"],
                    filters[filt]["responsivity"],
                ),
            }
        )
    for filt in filters:
        filters[filt] = normalize_power(filters[filt]["responsivity"], bins)
    for filt in filters:
        filters[filt] = np.array(filters[filt]).tolist()
    filterset = {
        "name": name,
        "filters": json.dumps(filters),
        "wavelengths": str(bins.tolist()),
        "filter_wavelengths": str(waves.values.tolist()),
    }
    return visor.models.FilterSet(**filterset)
